package OOP.Geekbrains;

/*
 *   Ссылки
 *      - вопросы по собесежованию ООП
 *          https://javastudy.ru/interview/java-oop/
 *          https://vk.com/java2study
 *   Класс - это описания содержания и поведения будущего объекта
 *
 *   Поле/атрибут класса - это характеристика объекта
 *      - правильной организацией доступа к полям объекта является сокрытие через privat и доступ
 *          через getter/setter
 *
 *      - статические поля можно инициализировать при объявлении в статическои или динамическом
 *          блоке инициализации
 *
 *      - не статические поля можно инициализировать при объявлении в динамическом блоке
 *          инициализации или в конструкторе
 *
 * Блоки инициализации - представляют собой
 *          - наборы выражений инициализации полей,
 *          - размещенных внутри класса
 *          - вне объявления методов и конструкторов
 *      - выполняется так же как если бы располагался в верхней части тела любого конструктора
 *      - если блоков инициализации несколько они выполняются в порядке расположения в коде
 *      - блок инициализации способен генерировать исключения если их объявления перечислены
 *          в предложениях throws конструкторов класса
 *
 *      - бывают блоки инициализации:
 *          - статические
 *          - нестатические
 *          - блоки в анонимном классе
 *
 *      - порядок вызова конструкции и блоков инициализации потомка и родителя:
 *          - сначала вызываются все статические блоки от первного родителя до последнего потомка
 *          - потом попарно вызывается динамический блок инициализации и конструктор в той же
 *              последовательности
 *
 *
 *   Метод - это последовательность команд которые вызываются по определенному имени
 *
 *      Сигнатура метода - это имя метода и параметры (причем порядок параметров имеет значение)
 *          - в сигнатуру не входят:
 *                  - возвращаемое значение
 *                  - бросаемые им исключения
 *                  - модификаторы
 *
 *      Переопределение метода - это переписывание, переделывание уже существующего метода
 *
 *      Перегруженные методы - это методы с одинаковыми именами но с разными сигнатурами
 *          - какой из методов будет вызываться зависит от набора параметров
 *
 *      Нестатичесие методы могут перегрузить статические, это будут два разных метода для
 *          программы
 *          - статический метод будет доступен по имени класса
 *
 *      Статические методы базового класса переопределить нельзя
 *
 *   Объект - это экземпляр конкретного класса
 *
 *   ООП - это методология программирования, основанная на представлении программы в виде совокупности
 *      объектов, каждый из которых является экземпляром определенного класса, а классы образуют
 *      иерархию наследования
 *
 *   Основными принципами ООП являются абстракция, инкапсуляция, наследование и полиморфизм
 *
 *      Инкапсуляция - это сокрытие реализации путем добавления модификаторов доступа
 *           protected - видны только у наследуемых классов и внутри пакете, хороший выбор
 *           default - модификатор не позволяет получмть доступ к полям и методам родителя при наследовании
 *                       - позволяет пользоваться классом не наследуясь от него
 *           private - получить доступ к нему можно:
 *                       - через конструкторы
 *                       - через геттеры и сеттеры, или к любому публичному методу класса имеющего
 *                           доступ к privat полям
 *
 *      Наследование - это возможность передачи поведения дочерним классам, таким образом структурируя классы
 *           и все дочерние классы являются типом своего родителя
 *           - при обращении к класу наследника через класс родителя будут доступно только то поведение
 *               которое реализовано в родительском классе
 *
 *      Полиморфизм - это множественная реализация интерфейса базового класса в наследниках,
 *          поэтому является продолжением наследования
 *           - полиморфизм относится только к методам, поля не являются полиморфными и не перегружаются
 *               и принадлежат конкретному классу
 *
 *      Абстракция - означает выделение значимой информации и исключения из рассмотрения не значимой
 *          - с точки зрения программирования это правильная декомпозиция задачи на объекты
 *
 *   Конструкторы - это специальный метод который вызывается при создании класса
 *      - конструктор инициализирует объект непосредственно во время создания
 *
 *       Конструктор по умолчанию не принимаеи никаких параметров
 *
 *       Конструктор копирования принимает в качестве параметра объект класса
 *
 *       Конструктор с параметрами принимает на вход параметры (обычно необходимые для инициализации
 *          полей класса)
 *
 *   this - это ссылка на сам объект к полю или метода которого мы обращаемся (this хранит ссылку
 *           на саму себя)
 *
 *   super для конструктора - требуется для обращения к конструктору суперкласса так же как и к
 *           полю суперкласса
 *
 *   Cast
 *
 *   instanceof - возвращает true если объект является экземпляром класса или его потомком
 *
 *   Абстрактный класс - обобщенный класс являющийся базовым для его конкретныз реализаций
 *      использование абстрактных классов и методов позволяет описать некую абстракцию которая
 *      должна быть реализована в других классах
 *       - если хотя бы один метод в нем абстрактный то весь класс абстрактный
 *       - может иметь как
 *       - от интерфейсов отличается тем что:
 *               - имеет поля
 *               - может иметь реализацию методов
 *               - реализуется через наследование
 *
 *   Абстрактный метод - метод не имеющий реализации в абстрактном классе и
 *          требующий реализации в классах наследниках абстрактного класса
 *      - метод нельзя одновременно объявить статическим и абстрктным одновременно
 *
 *   Интерфейс - конструкция имплементирование которой позволяет определить
 *          поведения классов и их взаимодествия
 *       - состоит из полей которые могут быть только константами
 *       - и методами которые требуют реализации при имлементировании в классе (кроме дефолтных)
 *           - дефолтная реализация создана для упрощения однако если она используется в нескольких
 *               классах то требуется ее реализация
 *       - в отличие от абстрактного класса возможно применение нескольких интерфейсов к одному классу
 *               для классов множественное наследование невозможно.
 *               https://javarush.ru/groups/posts/1985-raznica-mezhdu-abstraktnihmi-klassami-i-interfeysami
 *       - интерфейсы так же могут наследоваться
 *       - интерфейсы не имеют конструкторов
 *       - при создании массива типа интерфейс будет доступен только тот метод который реализуется этим
 *           интерфейсом
 *           - не приводить типы
 *
 *  Разница между наследованием абстрактного метода и реализацией интерфейса:
 *      - в частном случае разницы не будет
 *
 *
 * static - модификатор static говорит что метод или поле класса принадлежит не объекту а классу,
 *              т.е. доступ можно получить и не создавая объекта класса
 *          - поля помеченные static инициализируются вначале инициализации класса
 *              - принадлежат классу и являются общими для всех образцов класса
 *
 *          - модификатор static может применяться к
 *              - методу
 *              - внутреннему классу
 *              - полю
 *              - к импортированным классам
 *
 *
 *          - на методы объявленные как статик накладываются ряд ограничений:
 *              - они могут вызывать только другие статические методы
 *              - они должны осуществлять доступ только к статическим переменным
 *              - они не могут ссылаться на члены типа this и super
 *              - метод static можно перегрузить но переопределить нельзя
 *
 *          - статический класс - это вложенный класс который может обращаться только
 *              к статическим полям обертывающего его класса в том числе и приватным
 *              -
 *  final
 *          - для переменной определяет что перенная является константой и может
 *                 быть определена только один раз
 *
 *          - для класса означает что от класса нельзя наследоваться
 *
 *          - для методов означает что методы нельзя переопределить
 *
 *
 * Object - основной класс от которого наследуются все остальные,
 *      например прямые наследники:
 *          System
 *          Math
 *          String
 *          Frame
 *          Random
 *      методы класса Object:
 *          Object clone() throws CloneNotSupportedException - создает копию объектов
 *          boolean equals(Object obj)  - сравнение содержимого объектов
 *          void finalize() throws Throwable - вызывается перед GC
 *          final native Class getClass() - возвращает объект типа Class
 *          int hashCode()  - хешкод объекта, фактически дает адрес в динамической памяти
 *          String toString() - строковое представление объекта
 *          notify(), notifyAll() - используется для поддержки многопоточности
 *          wait() - - используется для поддержки многопоточности
 */


public class Main {
    public static void main(String[] args) {

        //Пример 1 показывающий что поля родителя и потомка это разные поля
        //они не являются полиморфными и принадлежат только своему классу
        //name будет сохраняться разным и на уровне Base и на уровне Child
        class Base {
            public String name;

            public Base(String name) {
                this.name = name;
            }

            protected void Test() {
                System.out.println("Test from Base");
            }
        }

        class Child extends Base {
            public String name;

            public Child(String name, String name1) {
                //вызов конструктора суперкласса всегда должен быть первым, все остальные
                //методы суперкласса могут вызываться из любого места
                super(name);
                this.name = name1;

                System.out.println("Base: " + super.name);
                System.out.println("Child: " + this.name);
            }

            @Override
            protected void Test() {
                //не в конструкторе а обычном методе можно писать логику до вызова метода конструктора
                System.out.println("Это логика метода Test() Child, затем идет вызов Test() из Base");
                super.Test();
            }
        }

        System.out.println("\n---Пример 1---");
        Child child = new Child("Base", "Child");
        System.out.println("Будем вызывать из Child метод Test затем если есть обращение к методу Test() " +
                "класса Base вызов происходит по цепочке классов Child -> Base -> Object,");
        child.Test();




    }


}

package NestedClasses.part_01;
/*  Структура вложенных классов выглядит так:
    Nested classes - вложенный класс это класс объявленный внутри другого класса, не каждый вложенный класс
            явдяется внутренним
        - Inner class - внутренние классы
            - Inner class
            - Method-local Inner Class - локальный внутренний класс - это класс объявленный внутри метода - смысла
                    мало потому что нельзя пользоваться локальными переменными этого локального метода,часто
                    используется при  создании библиотек
            - Anonymous Inner Class - часто используются как слушатели, они реализуются без создания класса,
                    он будет существовать в одном едиснтвенном экземпляре в том месте где мы его создали
        - Static nested classes - статические вложенные классы, вложенными но не внутренними
            Статические внутренние классы не привязываются к экземпляру, используется для
                - декомпозиции
                - создании общих полей для всего внешнего класса
*
*   Взаимодействие внутреннего и основного класса
*       - внешний класс не имеет дотуп к полям внутреннего класса (только черерез создание объекта внутреннего класса
            потому что у одного внешнего класса может быть несколько экземпляров внутреннего класса )
             а внутренний класс имеет доступ к полям внешнего  даже к полям private внешнего класса поскольку для
             внутреннего класса внешняя оболовка - внешний класс всегда один
*/


public class MainNestedClass {

    public static void main(String[] args) {
        Dog dog = new Dog();
        //создание внутреннего класса
        Dog.DogAttribute dogAttribute = dog.new DogAttribute("Тузик", 5);
        System.out.println(dogAttribute);

        //Пример реализации анонимного внутреннего класса
        //в фигурных скобках можно изменить реализацию
        //в результате dog1 являеься наследником какого то класса Dog с переопределенным методом
        Dog dog1 = new Dog() {
            @Override
            public String toString() {
                return "У попа была собака он ее любил";
            }
        };
        System.out.println(dog1);

        //анонимные классы очень хорошо работают с интерфейсами
        //Вместо создания отдельного класса UsingInterfaceTest с реализацией интерфеса
        //все это можно сделать в коде
        Run run = new Run() {
            @Override
            public void runsDistance(Distance distance) {
                System.out.println("Реализация анонимного класса чепез интерфейс"
                + "дистанция забега = " + distance.getDistance());

            }

            @Override
            public void run() {
                System.out.println("Еше и run переопределили");
            }
        };
        run.runsDistance(new Distance());
        run.run();



    }
}
